from flask import Flask, request, Response, abort
import os
import tasks
import invoke
import pathlib
import logging

from google.oauth2 import id_token
from google.auth.transport import requests as reqs

app = Flask(__name__)
gunicorn_logger = logging.getLogger('gunicorn.error')
app.logger.handlers = gunicorn_logger.handlers
app.logger.setLevel(gunicorn_logger.level)


CONFIG_FILE="{{CONFIG_FILE}}"
SA_NAME="{{DEMO_BACKEND_SA_NAME}}"
BUILD_DIR=pathlib.Path('/app')


tasks.login_sa(invoke.Context(), 'demo-backend', build_dir=BUILD_DIR)

authorized_emails = [
    '{{PRINCIPAL}}',
    '{{DEMO_BACKEND_SA_NAME}}@{{PROJECT_ID}}.iam.gserviceaccount.com',
]

@app.before_request
def check_user_authentication():
    app.logger.info('[0] Begin check_user_authentication')

    verified_email = None

    auth = request.headers.get("Authorization", None)

    if auth is None:
        return abort(403)

    if not auth.startswith("Bearer "):
        return abort(403)

    token = auth[7:]  # Remove "Bearer: " prefix

    # Extract the email address from the token. Since there may be
    # two types of token provided (Firebase or Google OAuth2) and
    # failed verification raises an exception, need multiple
    # try/except blocks.

    info = None
    try:
        info = id_token.verify_firebase_token(token, reqs.Request())
    except ValueError:
        pass

    try:
        if info is None:
            info = id_token.verify_oauth2_token(token, reqs.Request())
    except ValueError:
        pass

    if info is None:
        return abort(403)

    if "email" not in info:
        return abort(403)

    verified_email = info["email"]
    app.logger.info(f'[0]   User: {verified_email}')
    if verified_email not in authorized_emails:
        return abort(403)
    app.logger.info(f'[0]   Authorized: {verified_email}')


@app.route('/')
def home():
  return Response(status='200', response='OK')


@app.route('/configuration', methods=['GET'])
def configuration():

  configuration_dict = {}
  for key in request.args:
    configuration_dict[key] = tasks.get(invoke.Context(), key, config_file=CONFIG_FILE, build_dir=BUILD_DIR)
  return configuration_dict


@app.route('/ping_webhook', methods=['GET'])
def ping_webhook():
  app.logger.info('ping_webhook:')
  if request.args['authenticated'] == 'true':
    authenticated = True
  elif request.args['authenticated'] == 'false':
    authenticated = False
  else:
    return Response(status=400, response=f'Value for "authenticated" must be one of [true, false], received: "{request.args["authenticated"]}"')

  app.logger.info(f'  authenticated: {authenticated}')
  result_dict = tasks.ping_webhook(invoke.Context(), sa_name=SA_NAME, authenticated=authenticated, config_file=CONFIG_FILE, build_dir=BUILD_DIR)
  app.logger.info(f'  ping_webhook: {result_dict["status"]}')
  return Response(**result_dict)


@app.route('/update_webhook', methods=['POST'])
def update_webhook():
  app.logger.info('update_webhook:')
  content = request.get_json(silent=True)

  allow_unauthenticated = content.get('allow_unauthenticated', True)
  app.logger.info(f'  allow_unauthenticated: {allow_unauthenticated}')
  ingress_settings = content.get('ingress_settings', 'all')
  app.logger.info(f'  ingress_settings: {ingress_settings}')

  result_dict = tasks.update_webhook(invoke.Context(), 
    sa_name=SA_NAME,
    allow_unauthenticated=allow_unauthenticated,
    ingress_settings=ingress_settings,
    config_file=CONFIG_FILE, build_dir=BUILD_DIR)
  app.logger.info(f'  update_webhook: {result_dict["status"]}')
  return Response(**result_dict)


@app.route('/update_security_perimeter', methods=['POST'])
def update_security_perimeter():
  app.logger.info('update_security_perimeter:')
  content = request.get_json(silent=True)
  restrict_cloudfunctions = content.get('restrict_cloudfunctions', True)
  app.logger.info(f'  restrict_cloudfunctions: {restrict_cloudfunctions}')
  restrict_dialogflow = content.get('restrict_dialogflow', True)
  app.logger.info(f'  restrict_dialogflow: {restrict_dialogflow}')
  result_dict = tasks.update_security_perimeter(
    invoke.Context(),
    config_file=CONFIG_FILE, build_dir=BUILD_DIR,
    restrict_cloudfunctions=restrict_cloudfunctions,
    restrict_dialogflow=restrict_dialogflow,
    sa_name=SA_NAME,
  )
  app.logger.info(f'  update_security_perimeter: TODO STATUS CODE')
  return Response(**result_dict)


if __name__ == "__main__":
    port = int(os.environ.get('PORT', 5000))
    app.run(debug=True, host='0.0.0.0', port=port)